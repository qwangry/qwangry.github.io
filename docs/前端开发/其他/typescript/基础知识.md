# 基础知识

## 与JavaScript的区别
typescript是JavaScript的超集，扩展了JavaScript的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。

![Alt text](./images/基础知识/image.png)

![Alt text](./images/基础知识/image-3.png)

typescript增加了：
![Alt text](./images/基础知识/image-4.png)

## typescript安装
`tsc`
```
npm install -g typescript
```

`app.ts`：
```ts
// Greets the world.
console.log("Hello world!");
```

通过运行typescript包安装的命令tsc来检查：
```bash
tsc app.ts
```

得到了一些文件输出。tsc 编译或转换为纯 JavaScript 文件后 app.ts 文件的输出`app.js`。

![Alt text](./images/基础知识/image-1.png)

使用node命令执行app.js文件：

```bash
node app.js
# Hello world!
```

![Alt text](./images/基础知识/image-2.png)

## 数据类型

- string、number和boolean

- 数组
> number[];

- 字面类型
> 除了通用类型string和number之外，还可以在类型位置引用特定的字符串和数字
> 
> let x: "hello" = "hello";
> 
> 变量只能有一个值并没有多大用处，但是通过将字面组合成联合，可以表达一个更有用的概念
> 
> function printText(s: string, alignment: "left" | "right" | "center") {...}
> 
> printText("Hello, world", "left");
> 
> printText("G'day, mate", "centre");
> 


- any
> 不希望某个特定的值导致类型检查错误时，可以使用any
> 
> let obj:any={x:0};

- 对象类型
> 要定义对象类型，只需要列出其属性及其类型
> 
> function printCoord(pt:{x:number; y:number}){}
> 
> printCoord({x:3,y:7});

`可选属性`：对象类型还可以指定它们的部分或全部属性是可选的，在属性名称后添加`?`即可
> 
> function printName(obj: { first: string; last?: string }) {}

- 联合类型
> 
> 联合类型是由两种或多种其他类型组成的类型，表示可能是这些类型中的任何一个值。这些类型中的每一种都称为联合的成员
> 
> `使用时只需要提供与联合的任何成员匹配的类型即可`
> 
> function printId(id: number | string) {}
> 
> printId(101);
> 
> printId("202");
> 

<!-- 
变量声明：
```ts
let a:number;
a=1;
// 需要指定变量类型，以后使用过程中只能是该类型
let c=false;
// 如果声明完变量直接进行赋值，ts可以自动对变量进行类型检测

function sum(a:number,b:number){
    return a+b;
}

// 指定返回值类型
function sum(a:number,b:number):number{
    return a+b;
}
``` -->

![Alt text](./images/基础知识/image-5.png)
<!-- ![Alt text](./images/基础知识/image-6.png) -->
<!-- ![Alt text](./images/基础知识/image-7.png) -->

<!-- ![Alt text](./images/基础知识/image-8.png) -->
<!-- ![Alt text](./images/基础知识/image-9.png) -->
<!-- ![Alt text](./images/基础知识/image-10.png) -->

<!-- ![Alt text](./images/基础知识/image-11.png) -->

<!-- ![Alt text](./images/基础知识/image-12.png) -->
<!-- ![Alt text](./images/基础知识/image-13.png) -->

<!-- ![Alt text](./images/基础知识/image-14.png) -->

<!-- ![Alt text](./images/基础知识/image-16.png) -->
<!-- ![Alt text](./images/基础知识/image-15.png) -->

<!-- ![Alt text](./images/基础知识/image-17.png) -->

<!-- 枚举： -->
<!-- ![Alt text](./images/基础知识/image-18.png) -->

<!-- ![Alt text](./images/基础知识/image-19.png) -->

<!-- ![Alt text](./images/基础知识/image-20.png) -->

### 类型别名  type
```ts
type Point = {
  x: number;
  y: number;
};

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });

type ID = number | string;
```
### 接口  interface
接口声明是命名对象类型的另一种方式：

```ts
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

#### 类型别名和接口的区别
interface的几乎所有功能都在type中可用，主要区别在于无法重新打开类型以添加新属性，而接口始终可扩展

```ts
// 扩展接口
interface Animal{
  name:string
}

interface Bear extends Animal{
  honey:boolean
}

// 通过交集扩展类型
type Animal={
  name:string
}

type Bear=Animal & {
  honey:boolean
}

// 向现有接口添加新字段
interface Window {
  title: string
}

interface Window {
  ts: TypeScriptAPI
}

const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});


// 类型创建后无法更改
type Window = {
  title: string
}

type Window = {
  ts: TypeScriptAPI
}
 // Error: Duplicate identifier 'Window'.
```

### 类型断言
有时候会得到TypeScript无法知道类型的信息

可以使用类型断言来指定更具体的类型

**as**
```ts
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
```

**尖括号语法**
```ts
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
```




## 编译选项

### 自动编译文件
编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

```bash
tsc xxx.ts -w
```

### 自动编译整个项目

- 直接使用tsc指令，可以自动将当前项目下的所有ts文件编译为js文件

- 直接使用tsc命令的前提是，在项目根目录下创建一个ts的配置文件tsconfig.json
![Alt text](./images/基础知识/image-21.png)


配置选项：

- include

  - 定义希望被编译文件所在的目录

  - 默认值：["\*\*/\*"]

  - 示例：

    - ```json
      "include":["src/**/*", "tests/**/*"]
      ```

    - 上述示例中，所有src目录和tests目录下的文件都会被编译

- exclude

  - 定义需要排除在外的目录

  - 默认值：["node_modules", "bower_components", "jspm_packages"]

  - 示例：

    - ```json
      "exclude": ["./src/hello/**/*"]
      ```

    - 上述示例中，src下hello目录下的文件都不会被编译

- extends

  - 定义被继承的配置文件

  - 示例：

    - ```json
      "extends": "./configs/base"
      ```

    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息

- files

  - 指定被编译文件的列表，只有需要编译的文件少时才会用到

  - 示例：

    - ```json
      "files": [
          "core.ts",
          "sys.ts",
          "types.ts",
          "scanner.ts",
          "parser.ts",
          "utilities.ts",
          "binder.ts",
          "checker.ts",
          "tsc.ts"
        ]
      ```

    - 列表中的文件都会被TS编译器所编译

  - compilerOptions

    - 编译选项是配置文件中非常重要也比较复杂的配置选项

    - 在compilerOptions中包含多个子选项，用来完成对编译的配置

      - 项目选项

        - target

          - 设置ts代码编译的目标版本

          - 可选值：

            - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext

          - 示例：

            - ```json
              "compilerOptions": {
                  "target": "ES6"
              }
              ```

            - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

        - lib

          - 指定代码运行时所包含的库（宿主环境）

          - 可选值：

            - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

          - 示例：

            - ```json
              "compilerOptions": {
                  "target": "ES6",
                  "lib": ["ES6", "DOM"],
                  "outDir": "dist",
                  "outFile": "dist/aa.js"
              }
              ```

        - module

          - 设置编译后代码使用的模块化系统

          - 可选值：

            - CommonJS、UMD、AMD、System、ES2020、ESNext、None

          - 示例：

            - ```typescript
              "compilerOptions": {
                  "module": "CommonJS"
              }
              ```

        - outDir

          - 编译后文件的所在目录

          - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置

          - 示例：

            - ```json
              "compilerOptions": {
                  "outDir": "dist"
              }
              ```

            - 设置后编译后的js文件将会生成到dist目录

        - outFile

          - 将所有的文件编译为一个js文件

          - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中

          - 示例：

            - ```json
              "compilerOptions": {
                  "outFile": "dist/app.js"
              }
              ```

        - rootDir

          - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录

          - 示例：

            - ```json
              "compilerOptions": {
                  "rootDir": "./src"
              }
              ```

        - allowJs

          - 是否对js文件编译

        - checkJs

          - 是否对js文件进行检查

          - 示例：

            - ```json
              "compilerOptions": {
                  "allowJs": true,
                  "checkJs": true
              }
              ```

        - removeComments

          - 是否删除注释
          - 默认值：false

        - noEmit

          - 不对代码进行编译
          - 默认值：false

        - sourceMap

          - 是否生成sourceMap
          - 默认值：false

          

      - 严格检查

        - strict
          - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查
        - alwaysStrict
          - 总是以严格模式对代码进行编译
        - noImplicitAny
          - 禁止隐式的any类型
        - noImplicitThis
          - 禁止类型不明确的this
        - strictBindCallApply
          - 严格检查bind、call和apply的参数列表
        - strictFunctionTypes
          - 严格检查函数的类型
        - strictNullChecks
          - 严格的空值检查
        - strictPropertyInitialization
          - 严格检查属性是否初始化

      - 额外检查

        - noFallthroughCasesInSwitch
          - 检查switch语句包含正确的break
        - noImplicitReturns
          - 检查函数没有隐式的返回值
        - noUnusedLocals
          - 检查未使用的局部变量
        - noUnusedParameters
          - 检查未使用的参数

      - 高级

        - allowUnreachableCode
          - 检查不可达代码
          - 可选值：
            - true，忽略不可达代码
            - false，不可达代码将引起错误
        - noEmitOnError
          - 有错误的情况下不进行编译
          - 默认值：false


## 参考链接

[https://www.runoob.com/typescript/ts-tutorial.html](https://www.runoob.com/typescript/ts-tutorial.html)

[https://nodejs.cn/typescript/handbook/](https://nodejs.cn/typescript/handbook/)


