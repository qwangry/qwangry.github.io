# 数组

数组是一个包含了多个值的对象。

## 创建数组

```javascript
let test=["bread","milk"]
```

## 访问和修改数组袁术

```javascript
test[0]
// 修改
test[0]="cheese"
```
## 获取数组长度
```javascript
test.length

for (let i=0; i < test.length; i++){
    console.log(test[i])
}
```

## 一些方法
### 字符串和数组之间的转换

```javascript
let myData = "Manchester,London,Liverpool,Birmingham,Leeds,Carlisle";
let myArray = myData.split(",");
myArray;
let myNewString = myArray.join(",");
myNewString;
let dogNames = ["Rocket", "Flash", "Bella", "Slugger"];
dogNames.toString(); //Rocket,Flash,Bella,Slugger
```

### 添加和删除数组项

在数组末尾添加或删除一个项目，使用`push()`和`pop()`

```javascript
myArray.push("Cardiff");
myArray;
myArray.push("Bradford", "Brighton");
myArray;
myArray.pop();
let removedItem = myArray.pop();
myArray;
removedItem;
```

`unshift()`和`shift()`功能上和`push()`和`pop()`完全相同，只是分别作用于数组的开始，而不是结尾

### slice()
从数组提取一个片段，并作为一个新数组返回
```
let myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// 从索引 1 开始，提取所有的元素，直到索引 3 为止
```

### concat()
连接两个或多个数组并返回一个新的数组
```
let myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray 现在是 ["1", "2", "3", "a", "b", "c"]
```

### at()
返回数组中指定索引处的元素，如果超出范围，返回undefined。主要用于从数组末尾访问元素的负下标
```
const myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d"，myArray 的倒数第二个元素
```

### splice()
从数组移除一些元素，并（可选的）替换它们。返回从数组中删除的元素
```
const myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray 现在是 ["1", "a", "b", "c", "d", "5"]
// 本代码从 1 号索引开始（或元素“2”所在的位置），
// 移除 3 个元素，然后将后续元素插入到那个位置上。
```

### reverse()
原地颠倒数组元素的顺序，返回对数组的引用。
```
const myArray = ["1", "2", "3"];
myArray.reverse();
// 将原数组颠倒，myArray = [ "3", "2", "1" ]
```

### flat()
返回一个新数组，所有子数组元素递归地连接到其中，直到指定的深度。
```
let myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray 现在是 [1, 2, 3, 4]，因为子数组 [3, 4] 已被展平
```

### sort()
对数组的元素进行适当的排序，并返回对数组的引用
```
const myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// 对数组排序，myArray = ["Fire", "Rain", "Wind"]
```


### indexOf() 
在数组中搜索 searchElement 并返回第一个匹配的索引。

### lastIndexOf() 
从末尾开始，反向搜索。

### forEach()
对数组中的每个元素执行callback并返回undefined
```
const a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// 输出：
// a
// b
// c
```

### map()
返回由每个数组元素上执行callback的返回值所组成的新数组
```
const a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']
```

### flatMap()
先执行map()，再执行深度为1的flat()
```
const a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']
```

### filter()
返回一个新数组，其中包含callback返回true的元素
```
const a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]
```

### find()
返回callback返回true的第一个元素
```
const a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10
```

### findLast()
callback为true的最后一个元素

### findIndex()
返回callback返回为true的第一个元素的索引

### findLastIndex()
callback返回true的最后一个元素的索引

### every()
如果callback对数组中的每一个元素都返回true，则every()方法返回true
```
function isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false
```

### some()
至少一个元素返回true，则some()方法返回true
```
function isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false
```

### reduce()
对数组中的每个值执行callback(accumulator,currentValue,currentIndex,Array)，目的是将列表中的元素减少到单个值。reduce 函数返回 callback 函数返回的最终值。

如果指定了 initialValue，则调用 callback，并将 initialValue 作为第一个参数值，将数组中第一个元素的值作为第二个参数值。

如果没有指定 initialValue，那么 callback 的前两个参数值将是数组的第一个和第二个元素。之后的每一次调用，第一个参数的值将是前一个调用中返回的 callback，第二个参数的值将是数组中的下一个值。

如果 callback 需要访问正在处理的元素的索引，或者访问整个数组，它们可以作为可选参数。
```
const a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60
```

### reduceRight()
类似于reduce，但从最后一个元素开始


## Array
Array对象支持在单个变量名下存储多个元素，并具有执行常见数组操作的成员

数组不是基本类型，而是具有以下特性的Array:
- 可调整大小，可以包含不同数据类型
- 不是关联数组，因此，不能使用任意字符串作为索引访问数组元素，但必须使用非负整数作为索引访问
- 索引从0开始
- 数组复制操作创建浅拷贝
::: info
`浅拷贝`：是属性与拷贝对象的属性共享相同引用的副本。当更改源或副本时，也可能导致其他对象也发生更改。

`深拷贝`：源和副本是完全独立的。

在 JavaScript 中，所有标准的内置对象复制操作（展开语法、Array.prototype.concat()、Array.prototype.slice()、Array.from()、Object.assign() 和 Object.create()）创建的是浅拷贝而不是深拷贝。
:::

## 索引集合类
按索引值排序的数据集合。包括数组和类数组结构。

### 创建数组

```javascript
const arr1 = new Array(element0, element1, /* … ,*/ elementN);
const arr2 = Array(element0, element1, /* … ,*/ elementN);
const arr3 = [element0, element1, /* … ,*/ elementN];
```
element0, element1, …, elementN 是数组元素的值列表。当指定这些值时，数组将用它们作为数组的元素初始化。数组的 length 属性被设置为参数的数量。

括号语法称为“数组字面量”或“数组初始化式”。它比其他形式的数组创建更短，因此通常是首选。

**创建一个长度不为0，但又没任何元素的数组**
```javascript
// 这种方式...
const arr1 = new Array(arrayLength);

// ...与这种方式会形成相同数组
const arr2 = Array(arrayLength);

// 这个效果也一样
const arr3 = [];
arr3.length = arrayLength;
```

如果希望用单个元素初始化一个数组，而这个元素恰好又是 Number，必须使用括号语法。当单个 Number 传递给 Array() 构造函数时，将会被解释为 arrayLength，并非单个元素。
```javascript
// 创建一个只有唯一元素的数组：数字 42。
const arr = [42];

// 创建一个没有元素的数组，且数组的长度被设置成 42。
const arr = Array(42);

// 上面的代码与下面的代码等价：
const arr = [];
arr.length = 42;
```
也可以使用 Array.of 静态方法来创建包含单个元素的数组。

```javascript
const wisenArray = Array.of(9.3); // wisenArray 只包含一个元素：9.3
```

### 稀疏数组
数组可以包含“空槽”，这与用值 undefined 填充的槽不一样。空槽可以通过以下方式之一创建：

```javascript
// Array 构造函数：
const a = Array(5); // [ <5 empty items> ]

// 数组字面量中的连续逗号：
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// 直接给大于 array.length 的索引设置值以形成空槽：
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// 通过直接设置 .length 拉长一个数组：
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// 删除一个元素：
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]
```

在其他方法，特别是数组迭代方法时，空槽是被跳过的。

```javascript
const mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// 属性迭代
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// 输出：'0' '1' '4'
// 在对象中使用展开，使用属性枚举，而不是数组的迭代器
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }
```

### 多维数组
数组可以作为一个元素被包含在另外一个数组里面
```javascript
const a = new Array(4);
for (i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (j = 0; j < 4; j++) {
    a[i][j] = "[" + i + "," + j + "]";
  }
}
```

### 使用数组存储其他属性
```
const arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"
```

### 类数组对象

一些 JavaScript 对象，如 document.getElementsByTagName() 返回的 NodeList 或 arguments 等 JavaScript 对象，有与数组相似的行为，但它们并不共享数组的所有方法。arguments 对象提供了 length 属性，但没有实现如 forEach() 等数组方法。

不能直接在类数组对象上调用数组方法，但可以通过Function.prototype.call()间接调用

```
function printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}
```
