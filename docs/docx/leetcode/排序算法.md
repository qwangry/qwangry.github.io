# 排序算法

## 排序算法评价维度

- 运行效率：时间复杂度、总体操作数

- 就地性：原地排序在原数组上直接操作实现排序，无需借助额外的辅助空间，节省内存。通常，原地排序的数据搬运操作少，运行速度也更快。

- 稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不变。

- 自适应性：自适应排序的时间复杂度会受到输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。

- 是否基于比较：基于比较的排序依赖比较运算符（`>`，`=`，`<`）来判断元素的相对顺序，从而排序整个数组理论最优时间复杂度为`O(nlogn)`。而非比较排序不使用比较运算符，时间复杂度可达`O(n)`，但其通用性相对较差。

## 选择排序
循环，每轮从未排序区间选择最小的元素，放到已排序区间的末尾

```python
def select_sort(nums:list[int]):
    n=len(nums)
    # 外循环：未排序区间[i,n-1]
    for i in range(n-1):
        # 内循环：寻找最小元素
        k=i
        for j in range(i+1,n):
            if nums[j]<nums[k]:
                k=j
        nums[i],nums[k]=nums[k],nums[i]
```

### 特性

- 时间复杂度`O(n平方)`、非自适应性排序

- 空间复杂度`O(1)`、原地排序

- 非稳定性排序


## 冒泡排序

连续比较与交换相邻元素实现排序

> 如果"左元素 > 右元素"就交换，最终最大元素被移动到最右端

```python
def bubble_sort(nums:list[int]):
    n=len(nums)
    # 外循环: [0,i]
    for i in range(n-1,0,-1):
        # 内循环：把未排序区间中的最大元素交换到最右端
        for j in range(i):
            if nums[j]>nums[j+1]:
                nums[j],nums[j+1]=nums[j+1],nums[j]
```

### 优化

如果某一轮冒泡没有执行交换操作，说明已完成排序
```python
def bubble_sort_with_flag(nums:list[int]):
    n=len(nums)
    # 外循环：未排序区间 [0,i]
    for i in range(n-1,0,-1):
        flag=False
        # 内循环：把未排序区间中的最大元素交换到最右端
        for j in range(i):
            if nums[j]>nums[j+1]:
                nums[j],nums[j+1]=nums[j+1],nums[j]
                flag=True
        if not flag:
            break
```


### 特性
- 时间复杂度`O(n平方)`、自适应排序

- 空间复杂度`O(1)`、原地排序

- 稳定排序

## 插入排序
在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置

```python
def insertion_sort(nums:list[int]):
    # 外循环：已排序区间为[0, i-1]
    for i in range(1,len(nums)):
        # 基准元素
        base=nums[i]
        j=i-1
        # 内循环：将base插入已排序区间[0,i-1]中的正确位置
        while j>=0 and nums[j]>base:
            nums[j+1]=nums[j] # nums[j]向右移
            j-=1
        nums[j+1]=base # 将base放置到正确位置
```

### 特性
- 时间复杂度`O(n平方)`、自适应排序

- 空间复杂度`O(1)`、原地排序

- 稳定排序

### 优势

快速排序时间复杂度`O(nlogn)`，虽然插入排序时间复杂度更改，**但在数据量较小的情况下，插入排序通常更快**


## 快速排序

是一种基于分治策略的排序算法，运行高效，应用广泛

核心操作是**哨兵划分**，目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，大于基准数的元素移到其右侧

```python
def partition(self,nums:list[int],left:int,right:int)->int:
    # 以nums[left]为基准数
    i,j=left,right
    while i<j:
        # 从右到左寻找首个小于基准数的元素
        while i<j and nums[j]>=nums[left]:
            j-=1
        # 从左向右寻找首个大于基准数的元素
        while i<j and nums[i]<=nums[left]:
            i+=1
        # 元素交换
        nums[i],nums[j]=nums[j],nums[i]
    # 基准数交换到两子数组的分界线
    nums[i],nums[left]=nums[left],nums[i]
    return i # 返回基准数的索引


def quick_sort(self,nums:list[int],left:int,right:int):
    # 子数组长度为1时终止递归
    if left>=right:
        return 
    # 哨兵划分
    privot=self.partition(nums,left,right)
    self.quick_sort(nums,left,privot-1)
    self.quick_sort(nums,privot+1,right)
```

### 特性
- 时间复杂度`O(nlogn)`、自适应性排序

- 空间复杂度`O(n)`、原地排序

- 非稳定性排序

### 基准数优化
快速排序在某些输入下的时间效率可能降低。

极端例子，输入数组完全倒序，选择最左端元素作为基准数，在哨兵划分后，基准数被交换到最右端，导致左子数组长度为n-1，右子数组长度为0，这样递归，每轮哨兵划分都有一个子数组长度为0，分治策略失效，退化为“冒泡排序”的近似形式

**可以优化哨兵划分中的基准数的选取策略**

1、随机选取一个元素，但运气不好，每次都选到不理想的基准数，效率依旧不高；

2、`在数组中选取三个候选元素（通常是数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数`。

```python
 """选取三个候选元素的中位数"""
def media_three(self,nums:list[int],left:int,mid:int,right:int)->int:
    l,m,r=nums[left],nums[mid],nums[right]
    if (l<=m<=r) or (r<=m<=l):
        return mid # m在l,r之间
    if (m<=l<=r) or (r<=l<=m):
        return  left # l在m,r之间
    return right

def partition(self,nums:list[int],left:int,right:int)->int:
    med=self.media_three(nums,left,(left+right)//2,right)
    # 中位数交换到数组最左端
    nums[left],nums[med]=nums[med],nums[left]

    i,j=left,right
    while i<j:
        while i<j and nums[j]>=nums[left]:
            j-=1
        while i<j and nums[i]<=nums[left]:
            i+=1
        nums[i],nums[j]=nums[j],nums[i]
    nums[i],nums[left]=nums[left],nums[i]
    return i
```

### 尾递归优化

在某些情况下，快速排序可能占用空间较多

比如对于完全有序的输入数组，递归中的子数组长度为m，每轮哨兵划分操作都将产生长度为0的左子数组和长度为m-1的右子数组，意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到n-1，此时需要占用`O(n)`大小的栈帧空间

为了防止栈帧空间的累积，可以在每轮哨兵排序完成后，比较两个子数组的长度，仅对`较短的子数组`进行递归。较短数组的长度不会超过`n/2`，因此可以确保递归深度不超过`logn`，从而将最差空间复杂度优化至`O(n)`

```python
def quick_sort(self,nums:list[int],left:int,right:int):
    while left<right:
        privot=selft.partition(nums,left,right)
        # 对两个子数组中较短的那个执行快速排序
        if privot - left < right - privot:
            # 递归排序左子数组
            self.quick_sort(nums,left,privot-1)
            left=privot+1 # 剩余未排序区间[privot+1,right]
        else:
            # 递归排序右子数组
            self.quick_sort(nums,privot+1,right)
            right=privot-1 # 剩余未排序数组[left,privot-1]
```

## 归并排序
是一种基于分治策略的排序算法

包含划分和合并阶段：

1、划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题；

2、合并阶段：当子数组的长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束

```python
def merge(nums:list[int],left:int,mid:int,right:int):
    # 左子区间[left,mid]，右子区间[mid+1,right]
    # 创建临时数组 tmp，用于存放合并后的结果
    tmp=[0]*(right-left+1)
    # 初始化左子数组和右子数组的起始索引
    i,j,k=left,mid+1,0
    # 左右都有元素，比较，将较小元素复制到临时数组中
    while i<=mid and j<=right:
        if nums[i]<=nums[j]:
            tmp[k]=nums[i]
            i+=1
        else:
            tmp[k]=nums[i]
            j+=1
        k+=1
    # 将左右子数组的剩余元素复制到临时数组中
    while i<=mid:
        tmp[k]=nums[j]
        i+=1
        k+=1
    while j<=right:
        tmp[k]=nums[j]
        j+=1
        k+=1
    # 把临时数组tmp中的元素复制回原数组nums的对应区间
    for k in range(0,len(tmp)):
        nums[left+k]=tmp[k]

def merge_sort(nums:list[int],left:int,right:int):
    # 终止条件
    if left>=right:
        return
    # 划分阶段
    mid=(left+right)//2
    merge_sort(nums,left,mid) # 递归左子数组
    merge_sort(nums,mid+1,right) # 递归右子数组
    # 合并阶段
    merge(nums,left,mid,right)
```


### 特性
- 时间复杂度`O(nlogn)`、非自适应排序

- 空间复杂度`O(n)`、非原地排序

- 稳定排序

### 链表排序
对应链表，归并排序相较于其他排序算法具有显著优势，可以将链表排序任务的控制复杂度优化至`O(1)`


## 堆排序

### 堆
堆heap是一种满足特定条件的完全二叉树，主要可分为两种类型

- 小顶堆 min heap：任意节点的值小于等于子节点的值。

- 大顶堆 max heap：任意节点的值大于等于子节点的值。

特性：

- 最底层节点靠左天聪，其他层的节点都被填满

- 二叉树的根节点称为“堆顶”，底层最靠右的节点称为“堆底”

- 大顶堆，堆顶元素最大；小顶堆，堆顶元素最小

### 堆的常用操作

堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列

使用角度来看，可以将“优先队列”和“堆”看作等价的数据结构

常用操作：

- 入堆

- 堆顶元素出堆

- 访问堆顶元素

- 获取堆的元素数量

- 判断堆是否为空

```python
# python的heapq模块默认实现小顶堆
# 考虑将“元素取负”后再入堆，这样就可以将大小关系颠倒，从而实现大顶堆

# 初始化小顶堆
min_heap, flag = [], 1
# 初始化大顶堆
max_heap, flag = [], -1

# 元素入堆
heapq.heappush(max_heap, flag * 1)
heapq.heappush(max_heap, flag * 3)
heapq.heappush(max_heap, flag * 2)
heapq.heappush(max_heap, flag * 5)
heapq.heappush(max_heap, flag * 4)

# 获取堆顶元素
peek: int = flag * max_heap[0] # 5

# 堆顶元素出堆
# 出堆元素会形成一个从大到小的序列
val = flag * heapq.heappop(max_heap) # 5
val = flag * heapq.heappop(max_heap) # 4
val = flag * heapq.heappop(max_heap) # 3
val = flag * heapq.heappop(max_heap) # 2
val = flag * heapq.heappop(max_heap) # 1

# 获取堆大小
size: int = len(max_heap)

# 判断堆是否为空
is_empty: bool = not max_heap

# 输入列表并建堆
min_heap: list[int] = [1, 3, 2, 5, 4]
heapq.heapify(min_heap)
```

### 堆的实现——大顶堆

存储：堆是一种完全二叉树，完全二叉树非常适合用数组来表示

使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置，节点指针通过索引映射公式来实现

给定索引i，左子节点`2i+1`，右子节点`2i+2`

```python
def left(self,i:int)->int:
    return 2 * i + 1

def right(self,i:int)->int:
    return 2 * i + 2

def parent(self,i:int)->int:
    return (i-1)//2

# 访问堆顶
def peek(self)->int:
    return self.max_heap[0]

# 元素入堆，先添加到堆底
# 堆的成立条件可能被破坏，需要修复从插入节点到根节点的路径上的各个节点
# 称为堆化heapify
def push(self,val:int):
    self.max_heap.append(val)
    # 从底至顶堆化
    self.sift_up(self.size()-1)

def sift_up(self,i:int):
    # 从节点i开始堆化
    while True:
        p=self.parent(i)
        if p<0 or self.max_heap[i] <= self.max_heap[p]:
            break
        self.swap(i,p)
        i=p

# 堆顶元素出堆
# 交换堆顶元素与堆底元素
# 交换之后，删除堆底，然后从根节点，从顶至底执行堆化
def pop(self)->int:
    if self.is_empty():
        raise IndexError("堆为空")
    self.swap(0,self.size()-1)
    val=self.max_heap.pop()
    # 从顶至底堆化
    self.sift_down(0)
    return val

def sift_down(self,i:int):
    while True:
        l,r,ma=self.left(i),self.right(i),i
        if l<self.size() and self.max_heap[l]>self.max_heap[ma]
        
```


### 特性


## 桶排序


### 特性


## 计数排序


### 特性



## 基数排序


### 特性


## 总结

## 参考

[https://www.hello-algo.com/chapter_sorting/sorting_algorithm/](https://www.hello-algo.com/chapter_sorting/sorting_algorithm/)
