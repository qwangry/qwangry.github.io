# CSS基础

## CSS构建

### 层叠与继承
与层叠密切相关的概念是优先级，决定在发生冲突的时候应该使用哪条规则。

继承，默认情况，一些CSS属性继承当前元素的父元素上设置的值，有些则不继承。

层叠：样式表层叠——CSS规则的顺序很重要；应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。

优先级：浏览器根据优先级来决定多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。

继承：一些设置在父元素上的css属性可以被子元素继承，有些则不能。

控制继承：

css为控制继承提供了5个特殊的通用属性值，每个CSS属性都接收这些值。

- inherit：设置该属性会使子元素属性和父元素相同，“开启继承”

- initial：将应用于选定元素的属性值设置为该属性的初始值

- revert：将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。

- revert-layer：将应用于选定元素的属性值重置为在上一个层叠表中建立的值。

- unset：将属性重置为自然值，也就是如果属性是自然继承就是inherit，否则和initial一样

```css
a{
    color:inherit;
}
```

重设所有属性值：简写属性all可以同时将这些继承值中的一个应用于几乎所有属性，它的值可以是上述中任意一个。

```css
.fix-this{
    all:unset
}
```

**理解层叠**

重要性排序[后面的更重要]：

1、资源顺序

2、优先级

一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数：

ID：选择器中包含 ID 选择器则百位得一分。

类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。

元素：选择器中包含元素、伪元素选择器则个位得一分。

3、重要程度


内联样式，优先于所有普通的样式，无论其优先级如何

!important：覆盖所有上面所有优先级计算


### CSS选择器
CSS选择器是CSS规则的一部分，是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式。选择器所选择的元素，叫做“选择器的对象”。

#### 类型、类和ID选择器
```css
/* 类型选择器/标签名选择器/元素选择器 */
h1{

}

/* class选择器 */
.box{

}

/* ID选择器 */
#unqiue{

}
```

**全局选择器**
全局选择器是由一个星号(*)代指的，选中了文档中的所有内容
```css
*{
    marigin:0;
}
```

**类选择器**
以`.` 开头，会选择文档中应用了这个类的所有对象
```css
.highlight{
    background-color:yellow;
}
```

指向特定元素的类：
```css
span.highlight{
    background-color:yellow;
}
```

多个类被应用的时候指向一个元素：
```css
.notebox {
  border: 4px solid #666;
  padding: .5em;
}

.notebox.warning {
  border-color: orange;
  font-weight: bold;
}
```
```html
<div class="notebox">
    This is an informational note.
</div>

<div class="notebox warning">
    This note shows a warning.
</div>
```

**ID选择器**
以`#`开头
```css
#one{
    background-color:yellow;
}

h1#heading{
    color:rebeccapurple;
}
```

#### 标签属性选择器

```css
/* 根据一个元素上的某个标签的属性的存在以选择元素的不同方式： */
a[title]{

}

/* 或根据一个特定值的标签属性是否存在来选择 */
a[href="https://example.com"]
{

}
```

**存否和值选择器**
这些选择器允许基于一个元素自身是否存在或者基于各式不同的按属性值的匹配，来选取元素

- [attr] ：匹配带有一个名为attr的属性的元素

- [attr=value] ： 匹配带有一个名为attr的属性的元素，其值正为value

- [attr~=value] ： 匹配带有一个名为attr的属性的元素，其值正为value，或者匹配带有一个attr属性的元素，其值有一个或者更多，至少有一个和value匹配

- [attr|=value] ： 匹配带有一个名为attr的属性的元素，其值可正为value，或者开始为value，后面紧随着一个连字符

**子字符串匹配选择器**
- [attr^=value]	li[class^="box-"]	匹配带有一个名为attr的属性的元素，其值开头为value子字符串。

- [attr$=value]	li[class$="-box"]	匹配带有一个名为attr的属性的元素，其值结尾为value子字符串

- [attr*=value]	li[class*="box"]	匹配带有一个名为attr的属性的元素，其值的字符串中的任何地方，至少出现了一次value子字符串。

**大小写敏感**
如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用i值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML 中是大小写敏感的。
```css
li[class^="a" i] {
  color: red;
}
```

#### 伪类与伪元素
伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。

伪类就是开头为冒号的关键字：
```css
:pseudo-class-name
```

伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。
```css
::pseudo-element-name
```

把伪类和伪元素组合起来，
```css
article p:first-child::first-line{
    font-size:120%;
    font-weight:bold;
}
```

生成带有::before和::after的内容

伪类：

`:active`

`:any-link`

`:blank`

`:checked`

`:current`

`:default`

`:dir`

等等


伪元素：

`::after`

`::before`

`::first-letter`

`::first-line`

`::grammer-error`

`::selection`

等等


```css
/* 包含了伪类，用来样式化一个元素的特定状态 */
a:hover{

}

/* 还可以包含了伪元素，选择一个元素的某个部分而不是元素自己 */
p::first-line{

}
```

#### 关系选择器 运算符
将其他选择器组合起来，更复杂的选择元素
```css
article > p {

}
```

**后代选择器**
用单个空格字符——组合两个选择器。选择器利用后代组合符被称作后代选择器。

```css
body article p
```

**子代关系选择器**
子代关系选择器是个大于号`>`，只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。

```css
article > p
```

**邻接兄弟**
邻接兄弟选择器`+`用来选中恰好处于另一个在继承关系上同级的元素旁边的对象

```css
p + img
```

**通用兄弟**
如果想选中一个元素的兄弟元素，即使它们不直接相邻，还是可以使用通用兄弟关系选择器`~`

```css
p ~ img
```

**使用关系选择器**
可以将任何选择器组合起来

```css
ul > li[class="a"]{

}
```

### 盒模型
css中有几种类型的盒子，一般分为区块盒子block boxes和行内盒子inline boxes

类型指的是盒子在页面流中的行为方式以及与页面上其他盒子的关系。

盒子有内部显示inner display type和外部显示outer display type两种类型

外部显示类型：

- 拥有 block 外部显示类型的盒子：盒子会产生换行；width和height属性可以发挥作用；内边距、外边距和边框会将其他元素从当前盒子周围“推开”；未指定width，大多数情况，盒子会变得与其容器一样宽，占据可用空间的100%

- 拥有 inline 外部显示类型的盒子：盒子不会产生换行；width和height属性不起作用；垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于inline状态的盒子推开；水平方向的内边距、外边距以及边框会被应用且会把其他处于inline状态的盒子推开

某些 HTML 元素，如 `<a>`、 `<span>`、 `<em>` 以及 `<strong>`，默认使用 inline 作为外部显示类型。

内部显示类型：决定了盒子内元素的布局方式

区块和行内布局是网络上的默认行为方式。默认情况下，在没有任何其他指令的情况下，方框内的元素也会以标准流的方式布局，并表现为区块或行内盒子。

#### CSS盒模型
CSS 盒模型整体上适用于区块盒子，它定义了盒子的不同部分（外边距、边框、内边距和内容）如何协同工作，以创建一个在页面上可以看到的盒子。行内盒子使用的只是盒模型中定义的部分行为。

为了增加复杂性，有一种标准盒模型和一种替代盒模型。默认情况下，浏览器使用标准盒模型。

CSS中组成一个区块盒子：

- 内容盒子

- 内边距盒子：padding

- 边框盒子：border

- 外边距盒子：margin

标准盒模型：

在标准盒模型中，如果在盒子上设置 inline-size和block-size(或width和height)属性值，这些值就定义了内容盒子的 inline-size 和 block-size（水平语言中为 width 和 height）。然后将任何内边距和边框添加到这些尺寸中，以获得盒子所占的总大小。

替代盒模型：

在替代盒模型中，任何宽度都是页面上可见方框的宽度。内容区域的宽度是该宽度减去填充和边框的宽度。无需将边框和内边距相加，即可获得盒子的实际大小。


**display: inline-block**

display: inline-block 是 display 的一个特殊值，它提供了介于 inline 和 block 之间的中间位置。如果不希望项目换行，但又希望它使用 width 和 height 值并避免出现上述重叠现象，请使用它


### 背景与边框


### 处理不同的文本方向


### 溢出的内容


### 值和单位



### 在CSS中调整大小


### 图片、媒体和表单元素


### 样式化表格


### 调试CSS


### 组织CSS


















