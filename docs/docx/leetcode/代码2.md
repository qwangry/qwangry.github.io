## 代码2

## 优先级队列（二叉堆）heapq
最小元素heap[0]
```python
import heapq
pq=[]

heapq.heappush(pq,xxx)

heapq.heappop(pq)

# 如果插入的是个链表
# 需要写一个方法
class ListNode:
    def __init__(self,val=0,next=None):
        self.val=val
        self.next=next
    def __lt__(self,other):
        return self.val<other.val
# 或者这样写__lt__方法：
ListNode.__lt__=lambda a,b:a.val<b.val

heapq.heappush(pq,head)

node=heapq.heappop()
```

## collections

### deque
class collections.deque([iterable[, maxlen]])

双向队列对象，从左到右初始化（append()），从iterable（迭代对象）数据创建。

如果maxlen没有指定或是None，deques可以增长到任意长度。

```python
from collections import deque
```

一些方法：
```python
# 添加到右端
append(x)

# 添加到左端
appendleft(x)

# 移除所有元素
clear()

# 创建浅拷贝
copy()

# 3.5新版功能
# 计算元素中等于x的个数
count(x)

# 移去并返回一个元素，最右边
pop()

# 移去并返回一个元素，最左边
popleft()

# 移除找到的第一个value
remove(value)

# 逆序
reverse()

# 3.2功能 
# 扩展右侧
extend(iterable)

# 扩展左侧
extendleft(iterable)

# 返回 x 在 deque 中的位置（在索引 start 之后，索引 stop 之前）。 返回第一个匹配项，如果未找到则引发 ValueError。
index(x[, start[, stop]])

# 向右循环移动 n 步。 如果 n 是负数，就向左循环。
# 向右循环移动一步就等价于 d.appendleft(d.pop()) ， 向左循环一步就等价于 d.append(d.popleft()) 
rotate(n=1)
```

### defaultdict
class collections.defaultdict(default_factory=None, /[, ...])

一个新的类似字典的对象。 defaultdict 是内置 dict 类的子类。 它重载了一个方法并添加了一个可写的实例变量。

支持标准dict操作

包含一个名为 default_factory 的属性，构造时，第一个参数用于为该属性提供初始值，默认为 None。

```python
s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)
for k, v in s:
    d[k].append(v)
sorted(d.items())
# [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

s = 'mississippi'
d = defaultdict(int)
for k in s:
    d[k] += 1
sorted(d.items())
# [('i', 4), ('m', 1), ('p', 2), ('s', 4)]


s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]
d = defaultdict(set)
for k, v in s:
    d[k].add(v)
sorted(d.items())
# [('blue', {2, 4}), ('red', {1, 3})]
```

### OrderedDict
class collections.OrderedDict([items])

返回一个 dict 子类的实例，它具有专门用于重新排列字典顺序的方法。

```python
# 移除并返回一个(key,value)键值对，last为真，则按LIFO后进先出的顺序返回键值对，否则按照FIFO先进先出的顺序返回
popitem(last=True)

# 将一个现有的key移到序字典的任一端。如果last为真（默认），移到右端；否则，移到开头。
move_to_end(key, last=True)
```

### Counter
class collections.Counter([iterable-or-mapping])

是 dict 的子类，用于计数 hashable 对象。它是一个多项集，元素存储为字典的键而它们的计数存储为字典的值。计数可以是任何整数，包括零或负的计数值。

```python
c = Counter()                           # a new, empty counter
c = Counter('gallahad')                 # a new counter from an iterable
c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
c = Counter(cats=4, dogs=8)             # a new counter from keyword args
```

**elements()**
返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，elements() 将会忽略它。
```python
c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
# ['a', 'a', 'a', 'a', 'b', 'b']
```

**most_common([n])**
返回一个列表，其中包含 n 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 n 被省略或为 None，most_common() 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：

```python
Counter('abracadabra').most_common(3)
# [('a', 5), ('b', 2), ('r', 2)]
```

**subtract([iterable-or-mapping])**
减去一个 可迭代对象 或 映射对象 (或 counter) 中的元素。类似于 dict.update() 但是是减去而非替换。输入和输出都可以是 0 或负数。

```python
c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.subtract(d)
c
# Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})
```

**total()**
计算总计数值。

```python
c = Counter(a=10, b=5, c=0)
c.total()
# 15
```
