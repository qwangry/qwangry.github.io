# 面向对象

## 面向对象
面向对象编程将系统抽象为许多对象的集合，每一个对象代表了这个系统的特定方面。
### 类和实例

类并不做任何事情，只是一种用于创建具体对象的模板。

professor类
构造函数、属性、方法


具体传值的是实例


### 继承

Person类是Professor类和Student类的超类或父类，
Professor类和Student类是Person类的子类。

当一个方法拥有相同的函数名，但在不同类中可以具有不同的实现时，称这一特性为多态

当一个方法在子类中替换了父类的实现时，称之为子类重写/重载了父类中的实现

### 封装

保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为封装


### 面向对象与js

js的核心特性：
- 构造函数：基于类的面向对象编程中，类和对象是两个不同的概念，对象通常是类创造的实例，定义类的方式和实例化对象的方式不同。js中，会使用函数或对象字面量创建对象。js可以在没有特定的类定义的情况下创建对象，相对于基于类的面向对象编程，这种方式更轻量
- 原型链：很自然的实现了继承特性。但与继承仍有区别。继承是当一个子类完成继承时，由该子类所创建的对象既具有子类中单独定义的属性，又具有父类中定义的属性；原型链中，每个层级都代表了一个不同的对象，不同的对象之间通过__proto__属性链接起。原型链的行为更像是委派。委派同样是对象中的一种编程模式。当我们要求对象执行某项任务时，在委派模式下，对象可以自己执行该项任务，或者要求另一个对象（委派的对象）以其自己的方式执行这项任务。在许多方面，相对于继承来说，委派可以更为灵活地在许多对象之间建立联系（例如，委派模式可以在程序运行时改变、甚至完全替换委派对象）。

直接使用构造函数和原型去实现这些特性（例如继承）是棘手的，因此，JavaScript 提供了一些额外的特性，这些特性在原型这一模型之上又抽象出一层模型，将基于类的面向对象编程中的概念映射到原型中，从而能够更为直接地在 JavaScript 中使用基于类的面向对象编程中的概念。

## js中的类

### 类和构造函数

```
class Person {
  name;

  constructor(name) {
    this.name = name;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.name}`);
  }
}

const giles = new Person("Giles");

giles.introduceSelf(); // Hi! I'm Giles
```
构造函数使用constructor关键字来声明：
- 创建一个新的对象
- 将this绑定到这个新的对象
- 执行构造函数中的代码
- 返回这个新的对象

### 省略构造函数

如果不需要任何特殊的初始化内容，可以省略构造函数，默认的构造函数被自动生成
```
class Animal {
  sleep() {
    console.log("zzzzzzz");
  }
}

const spot = new Animal();

spot.sleep(); // 'zzzzzzz'
```

### 继承

```
class Professor extends Person {
  teaches;

  constructor(name, teaches) {
    super(name);
    this.teaches = teaches;
  }

  introduceSelf() {
    console.log(
      `My name is ${this.name}, and I will be your ${this.teaches} professor.`,
    );
  }

  grade(paper) {
    const grade = Math.floor(Math.random() * (5 - 1) + 1);
    console.log(grade);
  }
}

const walsh = new Professor("Walsh", "Psychology");
walsh.introduceSelf(); // 'My name is Walsh, and I will be your Psychology professor'

walsh.grade("my paper"); // some random grade
```

使用extends关键字来声明这个类继承自另一个类。

构造函数中要做的第一件事是使用super()调用父类的构造函数

### 封装
```
class Student extends Person {
  #year;

  constructor(name, year) {
    super(name);
    this.#year = year;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.name}, and I'm in year ${this.#year}.`);
  }

  canStudyArchery() {
    return this.#year > 1;
  }
}
```
`#year`是一个私有数据属性，类外部尝试访问`#year`，浏览器会抛出错误

### 私有方法

与私有数据属性一样，可以声明私有方法。

名称是以`#`开头，只能在类自己的方法中调用

```
class Example {
  somePublicMethod() {
    this.#somePrivateMethod();
  }

  #somePrivateMethod() {
    console.log("You called me?");
  }
}

const myExample = new Example();

myExample.somePublicMethod(); // 'You called me?'

myExample.#somePrivateMethod(); // SyntaxError
```
