# 面向对象

## 面向对象
面向对象编程将系统抽象为许多对象的集合，每一个对象代表了这个系统的特定方面。
### 类和实例

类并不做任何事情，只是一种用于创建具体对象的模板。

professor类
构造函数、属性、方法


具体传值的是实例


### 继承

Person类是Professor类和Student类的超类或父类，
Professor类和Student类是Person类的子类。

当一个方法拥有相同的函数名，但在不同类中可以具有不同的实现时，称这一特性为多态

当一个方法在子类中替换了父类的实现时，称之为子类重写/重载了父类中的实现

### 封装

保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为封装


### 面向对象与js

js的核心特性：

- 构造函数：基于类的面向对象编程中，类和对象是两个不同的概念，对象通常是类创造的实例，定义类的方式和实例化对象的方式不同。js中，会使用函数或对象字面量创建对象。js可以在没有特定的类定义的情况下创建对象，相对于基于类的面向对象编程，这种方式更轻量

- 原型链：很自然的实现了继承特性。但与继承仍有区别。继承是当一个子类完成继承时，由该子类所创建的对象既具有子类中单独定义的属性，又具有父类中定义的属性；原型链中，每个层级都代表了一个不同的对象，不同的对象之间通过__proto__属性链接起。原型链的行为更像是委派。委派同样是对象中的一种编程模式。当我们要求对象执行某项任务时，在委派模式下，对象可以自己执行该项任务，或者要求另一个对象（委派的对象）以其自己的方式执行这项任务。在许多方面，相对于继承来说，委派可以更为灵活地在许多对象之间建立联系（例如，委派模式可以在程序运行时改变、甚至完全替换委派对象）。

直接使用构造函数和原型去实现这些特性（例如继承）是棘手的，因此，JavaScript 提供了一些额外的特性，这些特性在原型这一模型之上又抽象出一层模型，将基于类的面向对象编程中的概念映射到原型中，从而能够更为直接地在 JavaScript 中使用基于类的面向对象编程中的概念。

## js中的类

### 类和构造函数

```
class Person {
  name;

  constructor(name) {
    this.name = name;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.name}`);
  }
}

const giles = new Person("Giles");

giles.introduceSelf(); // Hi! I'm Giles
```
构造函数使用constructor关键字来声明：
- 创建一个新的对象
- 将this绑定到这个新的对象
- 执行构造函数中的代码
- 返回这个新的对象

### 省略构造函数

如果不需要任何特殊的初始化内容，可以省略构造函数，默认的构造函数被自动生成
```
class Animal {
  sleep() {
    console.log("zzzzzzz");
  }
}

const spot = new Animal();

spot.sleep(); // 'zzzzzzz'
```

### 继承

```
class Professor extends Person {
  teaches;

  constructor(name, teaches) {
    super(name);
    this.teaches = teaches;
  }

  introduceSelf() {
    console.log(
      `My name is ${this.name}, and I will be your ${this.teaches} professor.`,
    );
  }

  grade(paper) {
    const grade = Math.floor(Math.random() * (5 - 1) + 1);
    console.log(grade);
  }
}

const walsh = new Professor("Walsh", "Psychology");
walsh.introduceSelf(); // 'My name is Walsh, and I will be your Psychology professor'

walsh.grade("my paper"); // some random grade
```

使用extends关键字来声明这个类继承自另一个类。

构造函数中要做的第一件事是使用super()调用父类的构造函数

### 封装
```
class Student extends Person {
  #year;

  constructor(name, year) {
    super(name);
    this.#year = year;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.name}, and I'm in year ${this.#year}.`);
  }

  canStudyArchery() {
    return this.#year > 1;
  }
}
```
`#year`是一个私有数据属性，类外部尝试访问`#year`，浏览器会抛出错误

### 私有方法

与私有数据属性一样，可以声明私有方法。

名称是以`#`开头，只能在类自己的方法中调用

```
class Example {
  somePublicMethod() {
    this.#somePrivateMethod();
  }

  #somePrivateMethod() {
    console.log("You called me?");
  }
}

const myExample = new Example();

myExample.somePublicMethod(); // 'You called me?'

myExample.#somePrivateMethod(); // SyntaxError
```

## 原型和原型链

js作者把构造函数作为原型代替class，同时规定必须满足以下条件：

- 首字母大写

- 内部使用this

- 搭配new生成实例

```js
function Person(name){
  this.name=name;
  this.sleep=function(){...}
}

```

> 如何区分一个function定义是构造函数还是普通函数？
> 
> - js引入new关键字来解决
> 
> - 因为构造函数只是定义原型（不占据内存），最终还是需要产生实例（占据内存）来处理流程，所以使用new关键字来产生实例
> 
> - 同时规定new后面跟的是构造函数，而不是普通函数。
> 
> - 这样就区分出定义的function是构造函数还是普通函数
> 

```js
var tom=new Person('tom');
```

### new执行过程

1、新的`对象实例`被创建，占据内存

2、this指向`实例`，任何this上的引用最终都指向实例

3、添加`__proto__`属性到`实例`上，并把`实例.__proto__`指向Person.prototype

4、执行构造函数，最终返回`实例对象`

#### 模拟new
```js
function objectFactory(){
  var obj=new Object();
  Constructor=[].shift.call(arguments);//取出第一个参数，即构造函数
  obj.__proto__=Constructor.prototype;
  var ret=Constructor.apply(obj,arguments);
  return typeof ret==='object' ? ret : obj;
}

var tom=objectFactory(Person,'tom');
tom.name		// tom
tom.sleep  // Function
```

### prototype

new和构造函数  模拟了 class类的概念，

使得产生的多个实例对象有共同的原型，同类型对象内在有了一些联系

但还有个问题：

每个实例对象本质上还是拷贝了构造函数对象里的属性和方法

这样每个实例的方法 创建了两个内存空间进行存储， 这样导致数据无法共享且浪费内存

#### 解决方案：prototype属性
为构造函数设置一个prototype属性来保存这些公用方法或属性

prototype属性是一个对象，可以扩展和覆写该对象

这样通过`new 构造函数()`生成实例时，这些实例的公用方法不会在内存创建多份，而是通过指针都指向构造函数的prototype属性

```js
# 扩展和覆写
Person.prototype.sleep=function(){...}
```
所以实例对象共享同一个prototype对象(构造函数的prototype属性)，外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像“继承”了prototype对象一样
> 所以js面向对象编程基于原型 

js规定，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象的所有属性和方法都会被构造函数的实例继承

### 原型链
> `如何把各个实例跟构造函数的prototype对象(原型对象)联系起来的？`
>
> **使用new关键字**
> 
> new关键字流程中有个步骤是，添加`__proto__属性`到实例上，并把实例的`__proto__`指向`构造函数的prototype`
> 
> 所以实例对象与原型对象间关联起来是通过`__proto__属性`

#### __proto__属性

当访问实例对象的属性或方法时，如果没有在实例上找到，js会顺着`__proto__`去查找原型，如果找到就返回。

由于原型对象也是一个对象，也可以有自己的原型对象，这样层层上溯，就形成了类似链表的结构，这就是原型链

JavaScript中所有的对象都有一个内置属性，称为它的`prototype（原型）`。

它本身是一个对象，所以原型对象也有它自己的原型，逐渐构成了原型链。

原型链终止于拥有null作为其原型的对象上。

> 当从object中读取一个缺失的属性时，JavaScript会自动从原型中获取该属性，这被称为“原型继承”
